**       **









# MySQL数据库设计规范





**文档总体说明：**

**编写目的：促成公司达成一种共同遵守的&quot;约定&quot;，使得每个人所做的工作模块统一协调起来，形成统一的风格和统一的技术特征，提高数据模块的重复利用率，提高项目的工作效率和对项目质量的管理和控制。**

**此外，也能让开发人员在数据库设计细节上达成共识，减少沟通成本，提高开发效率，增强系统的健壮性。**

**主要面向对象：WEB开发人员，尤其是使用MySQL数据库的开发人员**

**适用范围：使用MySQL数据库的项目**









### 第一章 命名规范

#### 第1条 基本规范
1. 原则：清晰明了，简洁准确，见名知意;
1. 组成：英文字母, 下划线, 阿拉伯数字;
1. 长度：最长64个字符，建议不超过32, 以免对后序的操作带来不便;
1. 命名方式
    1. 名称中除下划线、数字的部分，要使用英文单词或英文短语或相应缩写，不推荐使用汉语拼音;
    1. 禁止使用MySQL关键字和保留字，见附录-关键字和保留字;
    1. 禁止出现数字开头;
    1. 英文字母使用小写形式，避免因操作系统或mysql服务配置的不同引起的问题;
    1. 名词使用单数;
    1. 多个单词用下划线分隔;
    1. 禁止两个下划线中间只出现数字;

#### 第2条 具体规范
1. <a id="database_name" name="database_name">库命名</a>
    1. 使用项目名缩写作为前缀，如游戏项目： game_xxx;
    1. 库名长度控制在10个字符内，超出10个字符时，尽量使用单词缩写;
    1. 备份库必须以bak_为前缀，以日期为后缀 例：bak_video_20180307;
    1. 临时库必须以tmp_为前缀，以日期为后缀 例：tmp_video_20180307;
1. <a id="table_name" name="table_name">表命名</a>
    1. 用系统或模块的英文名的缩写作为前缀，优先使用模块名;
    1. 表名长度控制在15个字符内，超出15个字符时，尽量使用单词缩写;
    1. 备份表必须以bak_为前缀，以日期为后缀 例：bak_video_user_20180307;
    1. 临时表必须以tmp_为前缀，以日期为后缀 例：tmp_video_user_20180307;
1. <a id="column_name" name="column_name">字段命名</a>
    1. 避免出现数字;
    1. 除其它表的主键外，不需要添加前缀;
    1. 字段名长度控制在20个字符内，超出20个字符时，使用单词缩写;
1. <a id="index_name" name="index_name">索引命名</a>
    1. 主键索引名为pk_字段名，pk_即 primary key;
    1. 非唯一索引 按照 `idx_字段名称_字段名称[_字段名]`进行命名, idx_ 即 index;
    1. 唯一索引 按照 `uk_字段名称_字段名称[_字段名]` 进行命名, uk_ 即unique key;
    1. 如索引名过长，使用缩写;

### 第二章 注释

#### 第1条：表注释

1. 每个表必须要有注释;
1. 描述数据表用途;
1. 注释不超过30个字符;

#### 第2条：字段注释
1. 每个字段必须要有注释;
1. 描述该字段的用途及可能存储的内容，字段的取值含义或者范围;
1. 如果是枚举类型，将该字段中使用的内容都定义出来;
1. 注释不超过30个字符;

### 第三章 MySQL字符集

#### 第1条 推荐字符集
1. 非特殊需求，所有字符存储与表示，均使用utf8编码;
    ```
    解读：通用，无乱码风险，汉字3字节，英文1字节;
    ```
1. 如果需要存储表情符号，字段选择utf8mb4（utf8的超集）来进行存储;

#### 第2条  创建对象的字符集
1. 字符集和校对规则的4个级别 （从上到下，级别递减）
    1. 服务器级别;
    1. 数据库级别;
    1. 表级别、列级别;
    1. 连接级别;
1. 更低级别的设置会继承高级别的设置;
1. 通用规则
    1. 先为服务器或者数据库选择一个合理的字符集，然后根据不同的实际情况，让某个列选择自己的字符集;
    1. 字符集能表达的字符范围 utf8 &gt; gbk &gt; gb2312 &gt; latin1;
    1. 字符集中的ci 为 Case Insensitive (大小写不敏感)的缩写， cs 为Case Sensitive (大小写敏感)的缩写;
    1. 字符集中 bin 表示用二进制存储数据，用编码值进行比较，区分大小写;

#### 第3条  控制server和client端交互通信的字符集
1. character_set_server：mysql server默认字符集;
1. character_set_database：数据库默认字符集;
1. character_set_client：MySQL server假定客户端发送的查询使用的字符集;
1. character_set_connection：MySQL Server接收客户端发布的查询请求后，将其转换为character_set_connection变量指定的字符集;
1. character_set_results：mysql server把结果集和错误信息转换为character_set_results指定的字符集，并发送给客户端;
1. character_set_system：系统元数据(字段名等)字符集;

### 第四章 数据库设计

#### 第1条 命名
   见 [库命名规范](#database_name)

#### 第2条 排序规则/校验规则 (collation)
1. 尽量显式地设置字符集，而不是依赖于MySQL的默认设置
1. 如果不考虑占用空间及带宽因素，推荐使用utf-8

#### 第3条 数据库连接用完后,及时关闭
```
  解读：避免数据库连接数过大
```
#### 第4条 禁止使用存储过程,视图,触发器，Event
```
  解读：(1)对数据库影响较大，互联网业务，能让站点层和业务层做的事情，不要交到数据库层
    (2)调试、排错、迁移都比较困难，扩展性较差
```
### 第五章 数据表设计

#### 第1条 命名

  见 [表命名规范](#table_name)

#### 第2条 排序规则/校验规则 (collation)

1. 尽量显式地设置字符集
1. 结合业务使用英文字母大小写敏感/不敏感 的字符集

#### 第3条 表引擎

1. 默认使用InnoDB
1. 从大量的select操作性能上考虑，日志及报表类数据表适合使用 MyISAM引擎，其余推荐使用InnoDB
1. 从支持事务，大量的insert, update 操作上来考虑，与交易、审核、金额相关的表用 InnoDB
1. 归档数据表(可查询，不更新删除)，使用ARCHIVE引擎
1. 临时数据表，如数据量不大，不需要较高的数据安全生性，使用Memory引擎

#### 第4条 数据表存储内容

1. 单表数据行数建议控制在1000万以内，或者数据表占用磁盘空间不超过10G
1. 不在数据库中存储文件，应使用对应文件的路径
1. 禁止存储明文密码

#### 第5条 字段

1. 单表字段数建议不超过30
1. 字段数过多就进行垂直分表
    1. 冷热数据分离
    1. 大字段分离
    1. 常在一起作为条件和返回列的字段不分离

#### 第6条 表注释

 如果要创建同表A一样的表结构B
1. 推荐SQL语句：`create table B like A`, 或是先`show create table A`， 然后修改表名后执行
1. 避免使用 `create table B as select * from B` 来创建表（此操作只会创建表字段，而不会创建索引结构）

#### 第7条 表注释

 添加简洁明了的数据表功能说明, 详细见 表注释

### 第六章 字段设计

#### 第1条 命名

  见 [字段命名规范](#column_name)

#### 第2条 原则
1. 用尽量少的存储空间来存储一个字段的数据
1. 表内的每一行都应当被唯一地标识
1. 同一库中，不同表中相同含义的字段，字段名与字段类型要保持一致
1. 如无备注，所有字段都设置not null, 并设置默认值
    1. NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化
    1. NULL值需要更多的存储空间
    1. NULL 只能使用 IS NULL 或者 IS NOT NULL,而在=/!=/in/not in 时有坑
1. 禁止使用外键，如果要保证完整性，应由应用程式实现
    ```
      解读: 外键使得表之间相互耦合，update/delete等SQL操作，有可能造成死锁，高并发情况下容易成为数据库瓶颈
    ```
1. 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循:
    1. 不是频繁修改的字段
    1. 不是 varchar 超长字段，更不能是 text 字段

#### 第3条 强制字段
1. id 主键，类型为unsigned int (bigint)，自增，步长为1
1. 如业务需要以下字段，推荐以下命名与字段类型
    1. create_time, 创建时间； update_time, 更新时间
    1. 类型 推荐 datetime, 特点如下
        1. 日期查询速度快
        1. 可读性高
        1. 无时区变换问题

#### 第4条 字段类型选取
1. 根据业务区分使用tinyint/int/bigint,分别会占用1/4/8字节
    1. 能用tinyint 就不用int
    1. 能用int 就不用char或varchar
1. 根据业务区分使用char/varchar
    1. 字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高
    1. 字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间
1. 字段如果为非负数，必须是 unsigned
1. 使用varchar(20) 存储手机号，不要使用整数
    1. 牵扯到国家代号，可能出现 +/-/()等字符，例如 +86
    1. 手机号不会用来做数学运算
    1. varchar 可以模糊查询，例如 `like '150%'`;
1. 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint ( 1表示是，0表示否)
1. 小数类型为 decimal，禁止使用 float 和 double。
    ```
      解读:float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储
    ```
1. varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率
1. 减少text,blob类型，如必要，需要将text,blob字段拆分后单独存储
1. 使用tinyint类型替代enum类型
    ```
      解读： enum增加新值要进行DDL操作
    ```
1. 使用int unsigned存储IPV4 (使用php的 long2ip, ip2long 函数与 mysql 的 inet_aton, inet_aton) 进行转换
1. 如果有不可避免的join查询的业务场景，被join的字段必须类型相同，并建立索引
    ```
      解读：因为join字段类型不一致，会导致全表扫描
    ```
1. InnoDB引擎优先考虑使用varbinary存储大小写敏感的变长字符串或二进制内容

#### 第5条 表字段顺序
1. 从前到后，按照字段的重要性和使用频率排列，id 作为第一列
1. 按照字段的功能排列，功能相似的字段相邻排列
1. create_time，update_time 放在最后

#### 第6条 字段注释

  添加简洁明了的该列存储数据说明, 详细见 字段注释

### 第七章 索引设计

#### 第1条 命名

 见 [索引命名规范](#index_name)

#### 第2条 原则

1. 最左前缀匹配原则，
    ```
      解读：如果建立了索引(a,b,c)，相当于建立了 (a), (a,b), (a,b,c)
    ```
1. 为经常作为查询条件的字段建立索引
1. 为经常需要排序分组的字段创建索引
1. 选择区分度高的列作为索引（组合索引除外）
    1. 区分度计算：count(distinct left(列名, 索引长度))/count(\*)
    1. 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可
    ```
      解读：索引的长度与区分度是一对矛盾体，长度越长，区分度越高
    ```
1. 使用前缀索引
    1. 索引的值过长，会影响查询速度
    1. 要结合区分度，来选择合适长度的字段来建立索引
1. 如果字段事实上是与其它表的关键字相关联而未设计为外键引用，需建索引
1. 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引
1. 多表关联查询时，保证被关联的字段需要有索引
1. 有null 值存在的列，不要建索引
1. 单张表中索引数量不超过5个
    ```
      解读：尽可能合并单个，例：将索引(idx_c1),( idx_c2) 合并为 (idx_c1_c2) 或(idx_c2_c1),在同时包含c1,c2的查询中可以提高搜索效率，并且将显著减小索引占用空间
    ```
1. 单个索引中的字段数不超过5个
1. 禁止使用外键作为索引
1. 索引长度不能超出限制
    1. MyISAM: 所有索引字段定义长度的总和不能超过1000字节
    1. InnoDB:单一索引字段定义长度的总和不能超过767字节
1. 使用explain 测试索引

#### 第3条 索引分类

1. 唯一索引
    1. 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引
    1. 唯一索引的长度要和字段一致
    1. 禁止使用某字段的前N个字符做唯一索引
1. 组合索引
    1. 作为组合的查询条件、排序条件、分组条件中涉及的字段，可以建立组合索引
    1. 建组合索引的时候，区分度最高的在最左边
        1. 如果 `where a=? and b=?` ，a 列接近于唯一值，那么只需要单建 idx_a 索引即可
        1. 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如:`where a > ? and b=?` 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列
    1. order by 最后的字段是组合索引的一部分，并且要放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能
1. 全文索引
    1. 在MySQL5.6以下，只有存储引擎为MyISAM的数据表支持全文检索，MySQL5.6及以上，InnoDB引擎表才开始支持全文检索
    1.  MySQL全文索引只能对英文进行全文检索，本身不支持中文分词
    1. 只支持在char, varchar, text字段上创建fulltext indexes
    1. MySQL全文检索时，所有FULLTEXT索引列必须使用相同的字符集
    1. MySQL全文检索时，默认检索长度为4，即关键词的长度必须大于5才能被捕获

### 第八章 SQL规范

#### 第1条 禁止使用 `select *`, 只获取必要字段
1. `select *` 会增加cpu/io/内存/带宽的消耗
    1. 指定字段能够有效利用索引覆盖
    1. 指定字段查询，在表结构变更时，能够保证对应用程序无影响

#### 第2条  insert 必须指定字段，禁止使用 `insert into table values()`
```
解读：指定字段插入，在表结构变更时，能够保证对应用程序无影响
```
#### 第3条 隐式类型转换会使索引失效，导致全表扫描
#### 第4条 禁止在where条件中使用函数或者表达式
```
解读：会导致不能命中索引，全表扫描
```
#### 第5条 禁止负向查询，以及%开头的模糊查询
```
解读：会导致不能命中索引，全表扫描
```
#### 第6条 禁止大表join 和子查询
#### 第7条 同一个字段上的or必须写成in, in的值必须少于200个
#### 第8条 SQL语句尽可能简单，涉及到复杂SQL时，务必先参考已有索引设计，先explain
1. 简单SQL拆分，不以代码处理复杂为由。大语句拆小语句，减少锁时间
1. 例如or条件：`user_phone = '10086' or user_mobile = '10086'`，两个字段各自有索引，但只能用到其中一个。可以拆分成两个SQL，或者union all
1. 先explain 的好处是可以为了利用索引，增加更多查询限制条件

#### 第9条 能确定返回结果只有一条时，使用limit 1

#### 第10条 拒绝大事务

```
  解读：事务持有的锁等资源只有在事务rollback/commit时才释放
```

#### 第11条 禁止危险sql
1. 禁止类似 where 1=1 等无意义或恒真的条件，以免遇到update/delete操作
1. SQL中不允许出现DDL语句
1. delete, update 语句改成select 再explain

#### 第12条 考虑使用union all，少用union,注意考虑去重
1. union all 不去重，而少了排序操作，速度相对union要快，如果没有去重需求，优先使用union all
1. 如果union 结果中有使用limit, 在两个SQL可能有许多返回值的情况下，各自加上limit

#### 第13条 类似 `where c1 < 'a' order by c2` 的SQL
```
解读：用不到类似 (c1，c2)的索引，但可以利用(c2,c1)的索引
```
#### 第14条 分页优化
1. 使用合理的分页方式可以提高分页效率，大页情况下不使用跳跃式分页
1. 例：`select title from table order by update_time DESC limit 10000, 10;`
    因为MySQL使用的是提前读取策略，所以这种分页会导致大量的IO
1. 推荐分页方式 （适用于排序字段唯一的场景）
```
  select title from table where update_time < last_time order by update_time limit 10;
  其中，last_time 为上一次分页的界值
  弊端：update_time 值重复的记录可能被漏掉
```
#### 第15条 count计数
1. `count(*)` 对行的数目进行计算，包含NULL
1. `count(1)` 对结果集里以 primary key 统计数量 ，绝大多数情况下与`count(*)`效果一样
1. `count(c1)` 对特定的c1列的值具有的行数进行计算，不包含NULL
1. InnoDB存储引擎避免使用不带条件的 `count(*)`

#### 第16条 应用程序应该捕获SQL异常，并有相应处理
#### 第17条 性能分析工具
1. Show profile;
1. Mysqlsla;
1. Mysqldumpslow;
1. Explain;
1. Show slow log;
1. Show processlist;

### 第九章 分库分表

#### 第1条 分库分表的环境条件
1. 单机负载过高
1. 数据表的数据量太大，正常的运维工作影响业务访问
    1. 对数据库备份时间过长
    1. DDL操作锁表时间长
    1. 读写压力大
1. 数据表增长快，或无穷增长
1. 当前数据库、数据表设计不合理

#### 第2条 分库分表的原则
1. 能不分就不分
    1. 分库分表增加了业务逻辑的复杂度
    1. 优先从业务逻辑、实现方法上来解决问题
1. 出现在联表查询中的数据表，要分在一个库中
1. 避免造成跨库的事务

#### 第3条 分库分表方法
1. 垂直拆分
    1. 根据业务按照模块或冷热数据(表)进行分库 (如微服务所使用的方式)
    1. 把数据表字段按照冷热数据(字段)分离、大数据(字段)分离、关联数据(字段)不分离的原则进行拆分
1. 水平拆分
    1. 如事先可估算出表能达到的量，可以通过一定的算法，计算每一条数据要存放的表名
    1. 如表能达到的量级不能估算，则使用号段分表， 如 id 小于 1000w对应partition_1, id介于1000w - 2000w对应partition_2 ….

### 第十章 附录

#### 第1条 MySQL常用数据类型

1. 整数类型
    1. tinyint (1字节)
    1. smallint  (2字节)
    1. mediumint (3字节)
    1. int (4字节)
    1. bigint   (8字节)
1. 定点类型
    1. decimal  （对 `DECIMAL(M,D)` ，占用 `max(M, D)+2`字节）
1. 浮点类型
    1. float  (4字节)
    1. double   (8字节)
1. 字符类型
    1. char(Length)   (Length字节)
    1. varchar  (0-255字节)
    1. tinnytext (0-255字节)
    1. text (0-65535字节)
    1. mediumtext (0-16 777 215字节)
    1. longtext (0-4 294 967 295字节)
    1. tinyblob (0-255字节)
    1. blob (0-65535字节)
    1. mediumblob (0-16 777 215字节)
    1. longblob (0-4 294 967 295字节)
1. 日期类型
    1. date (3字节) 格式：YYYY-MM-DD 范围:1000-01-01/9999-12-31
    1. time (3字节) 格式：HH:MM:SS 范围: -838:59:59/838:59:59
    1. year (1字节) 格式：YYYY 范围: 1901/2155
    1. timestamp （4字节）范围：1970-01-01 00:00:00/2038-01-19 03:14:07 (GMT)
    1. datetime （8字节）范围：1000-01-01 00:00:00/9999-12-31 23:59:59
1. 枚举类型
    1. enum 最多65535个成员
    1. set 最多 64个成员

#### 第2条 MySQL关键字与保留字

MySQL关键字与保留字 数量较多(MySQL5.7版本 622)，不再一一列举，请见官方文档
    [https://dev.mysql.com/doc/refman/5.N/en/keywords.html#keywords-in-current-series](https://dev.mysql.com/doc/refman/5.7/en/keywords.html#keywords-in-current-series)
    自行替换版本
